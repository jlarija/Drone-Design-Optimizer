# Propeller properties
radiuses = np.concatenate((r_aft, r_front))
proprad = np.max(radiuses)  # [m] Propeller radius
mtow = MTOW_0  # [kg] Maximum take-off weight

# TBC properties
# TODO check whether this is outdated and whether we do want to keep the tbc and mineral wool?
# maybe ask the materials&structures department about this. I know the resin is what limits the CFiber resistance temperature but maybe there's
# inexpensive and strong resins? Need to find an expert on this

tTBC = 4.5 / 1000  # [mm] TBC thickness (1mm of CRFP)
rhoTBC = 170  # [kg/m3] TBC density
twool = 9 / 1000  # [mm] Wool thickness (1mm of CRFP)
rhowool = 20  # [kg/m3] Wool density

# Beam properties
L = proprad * 1.1  # [m] Propeller arm length

# Material properties #TODO check which material properties they are, but I am guessing a combination of carbon fiber at different fibres
sigma_yield = (231 + 269) / 2 * 10 ** 6  # [Pa] Yield strength
E = (55.1 + 60.6) / 2 * 10 ** 9  # [Pa] Young's modulus
density = (1450 + 1490) / 2  # [kg/m3] Density
shearstrength = (156 + 198) / 2 * 10 ** 6  # [Pa] Shear strength
G = (13.5 + 14.6) / 2 * 10 ** 6  # [Pa] Modulus of rigidity

# Applied forces
sf = 1.5
T1 = T_act / 2 * sf  # [N] Thrust generated by ONE propeller
T2 = T1

Wpropmot = (weight_onecoaxial_set + (
    0.8) * 9.81) * sf  # [N] Weight of TWO propellers and whatever is at the end of the arm
alpha = m.radians(0)  # [rad] Maximum thrust angle with vertical
Mz1 = 4.77 * sf  # [Nm] Torque created by ONE propeller #TODO make it read it from CRotor what the torque
Mz2 = Mz1

incr = 0.002  # [m] Step increase

# --------------------------------------------------------------------------------
# --- VERTICAL -------------------------------------------------------------------
# --------------------------------------------------------------------------------
Lsup = proprad
din_min = 0.070 + twool * 2  # [m] Minimum required inner diameter to house the motor

dout_sup = 0
masssup_optimal = 1000000

while dout_sup < 1:
    dout_sup = dout_sup + incr
    din_sup = 0
    while din_sup < 1:
        if dout_sup > din_sup and din_sup > din_min:

            areasup = 0.25 * m.pi * dout_sup ** 2 - 0.25 * m.pi * din_sup ** 2
            masssup = areasup * Lsup * density
            Ixx = m.pi / 64 * (dout_sup ** 4 - din_sup ** 4)

            sigmabend = (dout_sup / 2) * (weight_onecoaxial_set * 2) * Lsup / (4 * Ixx)

            sigmatension = (T1 - Wpropmot) / areasup
            K = 2
            Pcrit = m.pi * E * Ixx / ((K * L) ** 2)

            if abs(sigmatension) < sigma_yield and (T2 - Wpropmot) < Pcrit and masssup < masssup_optimal and abs(
                    sigmabend) < sigma_yield:
                doutsup_optimal = dout_sup
                dinsup_optimal = din_sup
                masssup_optimal = masssup
                sigmatension_opt = sigmatension
                bucklingforce = (T2 - Wpropmot)
                Pcrit_opt = Pcrit
                sigmabend_opt = sigmabend

        din_sup = din_sup + incr
if __name__ == "__main__":
    print()
    print("--- VERTICAL PART ---")
    print("Outer diameter [m]: ", doutsup_optimal)
    print("Inner diameter [m]: ", dinsup_optimal)
    print("Mass [kg]: ", masssup_optimal)
    print()
    print("Tension stress: ", sigmatension)
    print("Yield stress: ", sigma_yield)
    print("Buckling force: ", bucklingforce)
    print("Critical buckling force: ", Pcrit_opt)

tbcin = doutsup_optimal
tbcout = doutsup_optimal + tTBC * 2
tbcarea = m.pi * (tbcout / 2) ** 2 - m.pi * (tbcin / 2) ** 2
tbcmass = tbcarea * Lsup * rhoTBC

if __name__ == "__main__":
    print("TBC mass [kg]: ", tbcmass)

wooloutv = dinsup_optimal
woolinv = dinsup_optimal - twool * 2
woolareav = m.pi * (wooloutv / 2) ** 2 - m.pi * (woolinv / 2) ** 2
woolmassv = woolareav * Lsup * rhowool

if __name__ == "__main__":
    print("Wool mass [kg]: ", woolmassv)

    print()

# --------------------------------------------------------------------------------
# --- HORIZONTAL -----------------------------------------------------------------
# --------------------------------------------------------------------------------
# Some beginning values
mass_optimal = 100
d_out = 0
d_in = 0

# Design iteration PROPELLER ARM
while d_out < 1:
    d_out = d_out + incr
    d_in = 0
    while d_in < 1:
        if d_out > d_in:
            concept = 0

            # Beam properties
            area = 0.25 * m.pi * d_out ** 2 - 0.25 * m.pi * d_in ** 2
            Ixx = m.pi / 64 * (d_out ** 4 - d_in ** 4)
            mass = area * L * density

            # Forces and critical stresses
            Az = T1 + T2 - Wpropmot
            Mxa = (T1 + T2 - Wpropmot) * 0.5 * doutsup_optimal
            Mza = Mz1 + Mz2
            Bz = Az
            Mxb = Mxa - Az * L
            Mzb = Mza

            K = 2
            r = m.sqrt(Ixx / area)
            sigma_buck = m.pi ** 2 * E / ((K * L / r) ** 2)
            Pcrit = m.pi * E * Ixx / ((K * L) ** 2)  # [N] Critical buckling force

            # IN FLIGHT
            sigma1 = Mxb * (d_out / 2) / Ixx
            sigma2 = Mzb * (d_out / 2) / Ixx

            if abs(sigma1) < sigma_yield and abs(sigma2) < sigma_yield:
                concept = concept + 1

            # ON THE BUILDING - TOP ONES
            alpha = m.radians(0)
            Wpropmot_buck = m.cos(alpha) * Wpropmot
            Wpropmot_bend = m.sin(alpha) * Wpropmot
            sigma3 = (Wpropmot_bend * L) * (d_out / 2) / Ixx

            if abs(sigma3) < sigma_yield and Wpropmot_buck < Pcrit:
                concept = concept + 1

            # ON THE BUILDING - BOTTOM ONES
            Wpropmot_ten = Wpropmot_buck
            sigma4 = Wpropmot_ten / area

            if (abs(sigma3) + abs(sigma4)) < sigma_yield:
                concept = concept + 1

            # ON THE GROUND
            sigma5 = (Wpropmot * L) * (d_out / 2) / Ixx

            if abs(sigma5) < sigma_yield:
                concept = concept + 1

            if concept == 4 and mass < mass_optimal:
                dout_optimal = d_out
                din_optimal = d_in
                mass_optimal = mass
                sigma1opt = sigma1
                sigma2opt = sigma2
                sigma3opt = sigma3
                sigma4opt = sigma4
                sigma5opt = sigma5
                Wpropmot_buckopt = Wpropmot_buck
                sigma_buckopt = sigma_buck
                Pcrit_opt = Pcrit
                Ixx_opt = Ixx
                Mzbo = Mzb
                Mxbo = Mxb
                Bzo = Bz

        d_in = d_in + incr

# Determine deflection
defl = (T1 + T2 - Wpropmot) * L ** 3 / (3 * E * Ixx_opt)
theta = (T1 + T2 - Wpropmot) * L * L / (2 * E * Ixx_opt)

# Determine thrust in right direction percentage difference
Tnew = (T1 + T2) * m.cos(theta)
diff = (T1 + T2 - Tnew) / (T1 + T2) * 100

# Determine natural frequency
natfreq = 1 / (2 * m.pi) * (m.pi / L) ** 2 * (E * Ixx_opt / (mass_optimal / L)) ** 0.5

if __name__ == "__main__":
    print("--- HORIZONTAL PART ---")
    print("The moments:")
    print("Mzb: ", Mzbo)
    print("Mxb: ", Mxbo)
    print("Bz: ", Bzo)
    print("Outer diameter [m]: ", dout_optimal)
    print("Inner diameter [m]: ", din_optimal)
    print("Mass [kg]: ", mass_optimal)
    print()
    print("Max. deflection [m]: ", defl)
    print("Slope at the end of the arm [deg]: ", m.degrees(theta))
    print("This results in a difference in thrust of [%]: ", diff)
    print("Natural frequency [Hz]: ", natfreq)
    print()
    print("Yield stress [Pa]:", sigma_yield / (10 ** 6))
    print("Buckling stress [Pa]:", sigma_buckopt / (10 ** 6))

    print("Max. stress during flight [Pa]: ", sigma1opt / (10 ** 6))
    print("Max. stress during flight [Pa]: ", sigma2opt / (10 ** 6))

    print("Max. stress on the ground [Pa]: ", sigma5opt / (10 ** 6))
    print()
    print("Critical buckling force [N]: ", Pcrit_opt)
    print("Applied compression force [N]: ", Wpropmot_buckopt)

tbcinh = dout_optimal
tbcouth = dout_optimal + tTBC * 2
tbcareah = m.pi * (tbcouth / 2) ** 2 - m.pi * (tbcinh / 2) ** 2
tbcmassh = tbcareah * L * rhoTBC
if __name__ == "__main__":
    print("TBC mass [kg]: ", tbcmassh)

woolout = din_optimal
woolin = din_optimal - twool * 2
woolarea = m.pi * (woolout / 2) ** 2 - m.pi * (woolin / 2) ** 2
woolmass = woolarea * L * rhowool

if __name__ == "__main__":
    print("Wool mass [kg]: ", woolmass)
